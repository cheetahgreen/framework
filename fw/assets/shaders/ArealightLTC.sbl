version 1;
version glsl 330 core;

include "LTC.sbl";

shader "Arealight Linearly Tranformed Cosines"
{
  shared
  <<<
    uniform mat4 model;
    uniform mat4 view;
    uniform mat4 projection;
    uniform vec2 rectSize;
    uniform mat4 rectTransform;

    uniform sampler2D ltc_mat;
    uniform sampler2D ltc_mag;

    const float LUT_SIZE = 64.0;
    const float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;
    const float LUT_BIAS = 0.5/LUT_SIZE;
  >>>;

  struct vertex_layout
  {
    vec3 position  {location=0},
    vec3 normal    {location=1},
    vec2 tex_coord {location=2}
  };

  struct vertex_output
  {
    vec2 tex_coord,
    vec3 normal,
    vec3 view_position,
    vec3 view_direction
  };

  func vertex(vertex_layout vertex): vertex_output result
  <<<
    vec4 world_position = model * vec4(vertex.position, 1.0f);
    vec4 view_position = view * world_position;
    gl_Position = projection * view_position;

    result.tex_coord = vertex.tex_coord;

    mat3 normal_mtx = transpose(inverse(mat3(model)));
    mat3 view_normal_mtx = mat3(view) * normal_mtx;

    result.normal = normalize(view_normal_mtx * vertex.normal);
    result.view_position = view_position.xyz;
    result.view_direction = normalize(-view_position.xyz);
  >>>;

  func fragment(vertex_output vs_out): vec4 result
  <<<
    const float pi = 3.14159265;

    vec3 N = normalize(vs_out.normal);
    vec3 V = normalize(vs_out.view_direction);

    float roughness = 0.25;
    float theta = acos(dot(N, V));
    vec2 uv = vec2(roughness, theta/(0.5*pi));
    uv = uv * LUT_SCALE + LUT_BIAS;
    uv = uv.yx;

    vec4 t = texture(ltc_mat, uv);
    float mag = texture(ltc_mag, uv).r;

    mat3 Minv = mat3(
      vec3(1,   0,   t.y),
      vec3(0,   t.z, 0),
      vec3(t.w, 0,   t.x)
    );

    vec3 points[4];
    float hw = 0.5*rectSize.x;
    float hh = 0.5*rectSize.y;
    points[0] = (view * rectTransform * vec4(-hw, 0, -hh, 1.0)).xyz;
    points[1] = (view * rectTransform * vec4(-hw, 0, hh, 1.0)).xyz;
    points[2] = (view * rectTransform * vec4(hw, 0, hh, 1.0)).xyz;
    points[3] = (view * rectTransform * vec4(hw, 0, -hh, 1.0)).xyz;

    vec3 spec = ltc_evaluate(N, V, vs_out.view_position, Minv, points, false);
    spec *= mag;

    vec3 diff = ltc_evaluate(N, V, vs_out.view_position, mat3(1), points, false);

    vec3 color = diff+spec;
    color /= 2.0 * pi;

    result = vec4(color, 1.0);
  >>> requires { ltc_evaluate };
};
