version 1;
version glsl 330 core;

func blinnPhongSpecular(
    vec3 normalDir,
    vec3 viewDir,
    vec3 lightDir,
    float shininess
): float specularIntensity
<<<
    vec3 halfwayDir = normalize(viewDir + lightDir);
    specularIntensity = pow(max(dot(normalDir, halfwayDir), 0.0), shininess);
>>>;

shader "Uniform Phong Shader"
{
    shared
    <<<
        uniform sampler2D AlbedoMapSampler;
        uniform sampler2D NormalMapSampler;

        uniform vec3 LightColor;
        uniform vec3 EmissionColor;
        uniform vec4 SolidColor;
        uniform vec4 DiffuseMapColor;
        uniform vec3 LightDirection;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;
    >>>;

    struct vertexLayout
    {
        vec3 position {location = 0},
        vec3 texCoord {location = 1},
        vec3 normal   {location = 2},
        vec3 tangent  {location = 3}
    };

    struct vertexOutput
    {
        vec3 Normal,
        vec3 Tangent,
        vec2 TexCoord,
        vec3 ViewDirection,
        vec3 ViewLightDirection
    };

    func vertex(vertexLayout vertex): vertexOutput result
    <<<
        vec4 viewPosition = view * model * vec4(vertex.position, 1.0f);
        gl_Position = projection * viewPosition;

        result.TexCoord = vertex.texCoord.xy;

        mat4 normalMatrix = transpose(inverse(model));

        result.Normal = normalize(
            (view * normalMatrix * vec4(vertex.normal, 0)).xyz
        );

        result.Tangent = normalize(
            (view * normalMatrix * vec4(vertex.tangent, 0)).xyz
        );

        result.ViewDirection = normalize(-viewPosition.xyz);
        result.ViewLightDirection = normalize(
            (view * vec4(-LightDirection, 0)).xyz
        );
    >>>;

    func fragment(vertexOutput vsOut): vec4 result
    <<<
        vec3 normal = normalize(vsOut.Normal);
        vec3 tangent = normalize(vsOut.Tangent);
        vec3 lightDir = normalize(vsOut.ViewLightDirection);
        vec3 viewDir = normalize(vsOut.ViewDirection);

        vec4 albedoMapSample = texture(AlbedoMapSampler, vsOut.TexCoord);
        vec4 normalMapSample = texture(NormalMapSampler, vsOut.TexCoord);

        vec3 surfaceNormalTS = normalMapSample.rgb * 2.0 - 1.0;
        tangent = normalize(tangent - dot(tangent, normal) * normal);
        vec3 binormal = cross(normal, tangent);
        mat3 TBN = mat3(tangent, binormal, normal);
        vec3 surfaceNormal = normalize(TBN * surfaceNormalTS);

        float diffuse = max(dot(lightDir, surfaceNormal), 0.0);

        vec3 albedo = SolidColor.rgb
            + DiffuseMapColor.rgb * albedoMapSample.rgb;

        vec3 diffusePart = clamp(albedo * diffuse, 0, 1);

        float specularStrength = 0.2f;
        float specularIntensity = blinnPhongSpecular(
            surfaceNormal,
            lightDir,
            viewDir,
            64
        );

        vec3 specular =
            specularStrength * specularIntensity * vec3(1.0, 1.0, 1.0);

        result = vec4(EmissionColor + diffusePart + specular, SolidColor.a);
        //result.rgb = pow(result.rgb, vec3(1/2.2));
    >>> requires { blinnPhongSpecular };
};
