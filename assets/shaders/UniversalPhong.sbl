version 1;
version glsl 330 core;

func blinnPhongSpecular(
    vec3 normalDir,
    vec3 viewDir,
    vec3 lightDir,
    float shininess
): float specularIntensity
<<<
    vec3 halfwayDir = normalize(viewDir + lightDir);
    specularIntensity = pow(max(dot(normalDir, halfwayDir), 0.0), shininess);
>>>;

shader "Uniform Phong Shader"
{
    shared
    <<<
        uniform sampler2D TextureSlot1;
        uniform vec3 LightColor;
        uniform vec3 EmissionColor;
        uniform vec4 SolidColor;
        uniform vec4 DiffuseMapColor;
        uniform vec3 LightDirection;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;
    >>>;

    struct vertexLayout
    {
        vec3 position {location = 0},
        vec3 normal   {location = 1},
        vec3 texCoord {location = 2}
    };

    struct vertexOutput
    {
        vec3 Normal,
        vec2 TexCoord,
        vec3 ViewDirection,
        vec3 ViewLightDirection
    };

    func vertex(vertexLayout vertex): vertexOutput result
    <<<
        vec4 viewPosition = view * model * vec4(vertex.position, 1.0f);
        gl_Position = projection * viewPosition;

        result.TexCoord = vertex.texCoord.xy;

        result.Normal = normalize(
            (view * (transpose(inverse(model)) * vec4(vertex.normal, 0))).xyz
        );

        result.ViewDirection = normalize(-viewPosition.xyz);
        result.ViewLightDirection = normalize(
            (view * vec4(-LightDirection, 0)).xyz
        );
    >>>;

    func fragment(vertexOutput vsOut): vec4 result
    <<<
        vec3 normal = normalize(vsOut.Normal);
        vec3 lightDir = normalize(vsOut.ViewLightDirection);
        vec3 viewDir = normalize(vsOut.ViewDirection);

        float diffuse = max(dot(lightDir, normal), 0.0);

        vec3 albedo = SolidColor.rgb
            + DiffuseMapColor.rgb * texture(TextureSlot1, vsOut.TexCoord).rgb;

        vec3 diffusePart = clamp(albedo * diffuse, 0, 1);

        float specularStrength = 0.5f;
        float specularIntensity = blinnPhongSpecular(
            normal,
            lightDir,
            viewDir,
            64
        );

        vec3 specular =
            specularStrength * specularIntensity * vec3(1.0, 1.0, 1.0);

        result = vec4(EmissionColor + diffusePart + specular, SolidColor.a);
        result.rgb = pow(result.rgb, vec3(1/2.2));
    >>> requires { blinnPhongSpecular };
};
